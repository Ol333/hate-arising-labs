<ol class="breadcrumb">
  <li class="breadcrumb-item"><a href="{{ site.baseurl }}">Главная</a></li>
  <li class="breadcrumb-item"><a href="{{ site.baseurl }}/icpc/index.html">Спортивное программирование</a></li>
  <li class="breadcrumb-item active">Сортировки</li>
</ol>

<nav>
  <ul></ul>
</nav>

# Сортировки

Сортировка — упорядочивание набора однотипных данных по
возрастанию или убыванию.
Цель сортировки — облегчить последующий поиск элементов в
таком отсортированном массиве.

Дальше представлено 3 простых сортировки, одно улучшение и 6 сложных.

## Insertion sort
### Сортировка вставками

На каждом шаге алгоритма мы берем один элемент из входного массива данных и помещаем его на свое место (сравнивая с уже имеющимися) в отсортированный выходной массив.

(Цветом отмечено: белым — элемент, занявший свое место в отсортированной последовательности, темно-зеленым — элементы, которые поменяли свои места в массиве.)

<div class="card border-primary mb-2" style="max-width: 20rem;">
  <div class="card-body">
  <img src="{{ site.baseurl }}/img/vkluch2.png"
        focusable="false" width="100%"
        class="d-block user-select-none" />
  </div>
</div>

## Selection sort
### Сортировка выбором

Метод сортировки прямым выбором основан на следующих правилах:

1. Выбирается элемент с наименьшим ключом.
2. Он меняется местами с первым элементом $a_0$.
3. Затем эти операции повторяются с оставшимися $n-1$ элементами, $n-2$ элементами и так далее до тех пор, пока не останется один, самый большой элемент.

<div class="card border-primary mb-2" style="max-width: 20rem;">
  <div class="card-body">
  <img src="{{ site.baseurl }}/img/vibor1.png"
        focusable="false" width="100%"
        class="d-block user-select-none" />
  </div>
</div>

## Bubble sort
### Сортировка обменом, пузырьковая сортировка

Сравнение и смена мест для пары соседних элементов до тех пор, пока не будут упорядочены все элементы.

<div class="card border-primary mb-2" style="max-width: 25rem;">
  <div class="card-body">
  <img src="{{ site.baseurl }}/img/puzir2.png"
        focusable="false" width="100%"
        class="d-block user-select-none" />
  </div>
</div>

## Shaker sort
### Шейкерная сортировка

Напоминает приготовление коктейля, когда один стакан накрывают другим и встряхивают вверх-вниз.
При просмотре вверх на свое место всплывает самый легкий элемент, при просмотре вниз тонет на свое место "тяжелый" элемент.

<div class="card border-primary mb-2" style="max-width: 20rem;">
  <div class="card-body">
  <img src="{{ site.baseurl }}/img/sheicer1.png"
        focusable="false" width="100%"
        class="d-block user-select-none" />
  </div>
</div>

## QuickSort
### Быстрая сортировка или сортировка с разделением

Идея этого алгоритма заключается в следующем: произвольно разбить массив на две части (выбрав опорный элемент), добиться того, что все элементы левой части были больше или равны элементам правой части, далее поступить также с правой и левой частью, рассматривая их как отдельные массивы.

<div class="card border-primary mb-2" style="max-width: 15rem;">
  <div class="card-body">
  <img src="{{ site.baseurl }}/img/bistro.png"
        focusable="false" width="100%"
        class="d-block user-select-none" />
  </div>
</div>

##  Merge sort
### Слияние

Алгоритм данной сортировки:

1. Последовательность $а$ разбивается на две половины: $b$ и $с$.
2. Части $b$ и $с$ сливаются, при этом одиночные элементы образуют упорядоченные пары.
3. Полученная последовательность под именем а вновь обрабатывается, как указано в пунктах 1 и 2; при этом упорядоченные пары переходят в такие же четвёрки.

Повторяя предыдущие шаги, сливаем четвёрки в восьмёрки и т.д., каждый раз, удваивая длину слитых последовательностей до тех пор, пока не будет упорядочена последовательность целиком.

<div class="card border-primary mb-2" style="max-width: 10rem;">
  <div class="card-body">
  <img src="{{ site.baseurl }}/img/sli.png"
        focusable="false" width="100%"
        class="d-block user-select-none" />
  </div>
</div>

## Tree sort
### Сортировка деревом

Бинарное (двоичное) дерево поиска – это бинарное дерево, для которого выполняются следующие дополнительные условия (свойства дерева поиска):

* оба поддерева – левое и правое, являются двоичными деревьями поиска;
* у всех узлов левого поддерева произвольного узла $X$ значения ключей данных меньше, чем значение ключа данных самого узла $X$;
* у всех узлов правого поддерева произвольного узла $X$ значения ключей данных не меньше, чем значение ключа данных узла $X$.

Совершаем обход бинарного дерева в соответствии со следующими рекурсивными правилами:
1. Посетить во внутреннем порядке левое поддерево корня (если оно существует).
2. Посетить корень.
3. Посетить во внутреннем порядке правое поддерево корня (если оно существует).

<div class="row row-cols-1 row-cols-md-2">
  <div class="col-lg-4">
    <div class="card border-primary mb-2" style="max-width: 20rem;">
      <div class="card-body">
      <img src="{{ site.baseurl }}/img/tree2.png"
            focusable="false" width="100%"
            class="d-block user-select-none" />
      </div>
    </div>
  </div>
  <div class="col-lg-4">
    <div class="card border-primary mb-2" style="max-width: 20rem;">
      <div class="card-body">
      <img src="{{ site.baseurl }}/img/tree.png"
            focusable="false" width="100%"
            class="d-block user-select-none" />
      </div>
    </div>
  </div>
</div>

## Heapsort
### Пирамидальная сортировка или сортировка кучей

Пирамида, двоичная куча, пирамида, или сортирующее дерево — такое двоичное дерево, для которого выполнены три условия:

1. Значение в любой вершине не меньше, чем значения её потомков.
2. Глубина листьев (расстояние до корня) отличается не более чем на 1 слой.
3. Последний слой заполняется слева направо.

Алгоритм сортировки будет состоять из двух основных шагов:

1. Выстраиваем элементы массива в виде сортирующего дерева. Этот шаг требует $N$ операций.
2. Элемент корня меняется местами с последним, и рассматриваемый массив сокращается на один элемент. Возвращаемся к первому шагу. Процесс продолжается до тех пор, пока в сортирующем дереве не останется один элемент. Этот шаг требует ($n \log n$) операций.

<div class="row row-cols-1 row-cols-md-2">
  <div class="col-lg-4">
    <div class="card border-primary mb-2" style="max-width: 20rem;">
      <div class="card-body">
      <img src="{{ site.baseurl }}/img/pira0.2.png"
            focusable="false" width="100%"
            class="d-block user-select-none" />
      </div>
    </div>
  </div>
  <div class="col-lg-4">
    <div class="card border-primary mb-2" style="max-width: 20rem;">
      <div class="card-body">
      <img src="{{ site.baseurl }}/img/pira1.png"
            focusable="false" width="100%"
            class="d-block user-select-none" />
      </div>
    </div>
  </div>
</div>

## JSort
### J-сортировка

Построение двух пирамид (нисходящей и восходящей) значительно упорядочивает массив в обоих направлениях.
Сначала нужно осуществить построение невозрастающей кучи.
В результате меньшие элементы всплывают в верхние узлы пирамиды (что будет соответствовать левой половине массива), наименьший элемент окажется в корне.
Элементы находящиеся ближе к листьям дерева (им будет соответствовать вторая половина массива) будут иметь менее упорядоченный вид, поскольку они не сравнивались друг с другом, а просто были оттеснены на задворки в результате перемещения их родителей.
Для наведения относительного порядка в правой части массива следует построить кучу ещё раз, во всём противоположную первой. Во-первых, эта куча должна быть неубывающей.
Во-вторых, она должна быть «зеркальной» к массиву, то есть её корень должен соответствовать не первому, а последнему элементу и выстраивать дерево следует, перебирая массив от конца к началу.
В итоге получаем во многом упорядоченный массив.
Довершает дело сортировка вставками.

<div class="card border-primary mb-2" style="max-width: 20rem;">
  <div class="card-body">
  <img src="{{ site.baseurl }}/img/jsort.png"
        focusable="false" width="100%"
        class="d-block user-select-none" />
  </div>
</div>

## Radix sort
### Поразрядная сортировка или цифровая сортировка

Мы имеем массив `source = [9,5,15,6,7,8,13,11]`.

1. Создаем массив `count` из $m$ элементов (счетчиков);
2. Присваиваем `count[i]` количество элементов `sours`, равных $i$. Для этого:
    1. Обнулить все элементы `count`;
    2. Пройти по `count` от начала до конца, увеличивая для каждого числа значение элемента `count` с соответствующим номером. В нашем примере `count = [0,1,0,1,0,2,1,1,1,1]`.
3. Присвоить `count[i]` значение, равное сумме всех элементов до него:
`count[i] = count[0] + count[1] + … + count[i-1]`.
В нашем примере `count = [0,0,1,1,2,2,4,5,6,7]`.
Эта сумма является количеством элементов исходного массива, меньших $i$.
4. Расставляем элементы.
Для каждого числа `source[i]` мы знаем, сколько чисел меньше него – это значение хранится в `count[source[i]]`. Таким образом, нам известно место элемента в упорядоченном массиве: если есть $K$ чисел меньше данного, то оно должно стоять на $K+1$ месте. Осуществляем проход по массиву `source` слева направо, одновременно заполняя выходной массив `dest`. Таким образом, число `c = source[i]` ставится на место `count[c]`. Если числа повторяются в массиве, предусмотрен оператор, который увеличивает значение позиции для следующего числа $c$, если таковое будет.

<div class="card border-primary mb-2" style="max-width: 10rem;">
  <div class="card-body">
  <img src="{{ site.baseurl }}/img/por.png"
        focusable="false" width="100%"
        class="d-block user-select-none" />
  </div>
</div>

## Сравнение

Простые алгоритмы:
* устойчивы,
* просты в реализации,
* эффективны на малых массивах, упорядоченных массивах,
* долго работают на больших массивах.

<table class="table table-hover">
  <thead>
    <tr>
      <th scope="col">Название</th>
      <th scope="col">Сложность</th>
      <th scope="col">Кол-во сравнений<br>min | avg | max</th>
      <th scope="col">Кол-во перестановок<br>min | avg | max</th>
    </tr>
  </thead>
  <tbody>
    <tr class="table-active">
      <th scope="row">Включение</th>
      <td>O(n<sup>2</sup>)</td>
      <td>n-1 | (n<sup>2</sup>+n-2)/4 | (n<sup>2</sup>-n)/2</td>
      <td>2(n-1) | (n<sup>2</sup>+9n-10)/4 | (n<sup>2</sup>+3n-4)/2</td>
    </tr>
    <tr class="table-primary">
      <th scope="row">Выбор</th>
      <td>O(n<sup>2</sup>)</td>
      <td>(n<sup>2</sup>-n)/2 | (n<sup>2</sup>-n)/2 | (n<sup>2</sup>-n)/2</td>
      <td>3(n-1) | n(ln n +0,57) | n<sup>2</sup>/4+3(n-1)</td>
    </tr>
    <tr class="table-active">
      <th scope="row">обмен</th>
      <td>O(n<sup>2</sup>)</td>
      <td>(n<sup>2</sup>-n)/2 | (n<sup>2</sup>-n)/2 | (n<sup>2</sup>-n)/2</td>
      <td>0 | (n<sup>2</sup>-n)*1,5 | (n<sup>2</sup>-n)/4</td>
    </tr>
  </tbody>
</table>

Сложные алгоритмы

<table class="table table-hover">
<thead>
<tr>
  <th scope="col">Название</th>
  <th scope="col">Сложность</th>
  <th scope="col">Доп. память</th>
  <th scope="col">Устойчивость</th>
  <th scope="col">Достоинства</th>
  <th scope="col">Недостатки</th>
</tr>
</thead>
<tbody>
<tr class="table-active">
  <th scope="row">Шейкерная</th>
  <td>O(n<sup>2</sup>)</td>
  <td>O(1)</td>
  <td>устойчив</td>
  <td>быстрее сортировки пузырьком</td>
  <td>все равно долго работает</td>
</tr>
<tr class="table-primary">
  <th scope="row">Быстрая</th>
  <td>O(n log n)</td>
  <td>O(log n)</td>
  <td>неустойчив (используя O(n) дополнительной
  памяти, можно сделать сортировку устойчивой)</td>
  <td>один из самых быстродействующих алгоритмов</td>
  <td>плохо работает при неудачных данных</td>
</tr>
<tr class="table-active">
  <th scope="row">Пирамидальная</th>
  <td>O(n log n)</td>
  <td>O(1)</td>
  <td>неустойчив</td>
  <td>стабильность метода</td>
  <td>сложен в реализации, на почти отсортированных
  массивах работает столь же долго, как и на
  хаотических данных</td>
</tr>
<tr class="table-primary">
  <th scope="row">J-сортировка</th>
  <td>O(3n)/O(n<sup>2</sup>)</td>
  <td>O(1)</td>
  <td>неустойчив</td>
  <td>хорошо работает на малых массивах</td>
  <td>чем длиннее массив, тем дольше работает
  сортировка вставками</td>
</tr>
<tr class="table-active">
  <th scope="row">Слиянием</th>
  <td>O(n log n)</td>
  <td>O(n)</td>
  <td>устойчив</td>
  <td>Не имеет «трудных» входных данных</td>
  <td>На «почти отсортированных» массивах работает
  столь же долго, как на хаотичных</td>
</tr>
<tr class="table-primary">
  <th scope="row">Дерево</th>
  <td>O(n log n)</td>
  <td>O(n)</td>
  <td>неустойчив</td>
  <td>один из быстродействующих алгоритмов</td>
  <td>плохо работает при неудачных данных</td>
</tr>
<tr class="table-active">
  <th scope="row">Поразрядная</th>
  <td>O(nk)</td>
  <td>O(k)</td>
  <td>LSD-устойчив<br>
  MSD-неустойчив</td>
  <td>не основана на сравнениях</td>
  <td>узкая специализация</td>
</tr>
</tbody>
</table>

Вот данные, полученные в результате тестов с тысячью элементов массива и с сотней тысяч элементов (миллион элементов сортируется простым методом более часа).

<table class="table table-hover">
  <thead>
    <tr>
      <th scope="col">Сортировка<br>10<sup>3</sup> эл. (мс) / 10<sup>5</sup> эл. (мин:с:мс)</th>
      <th scope="col">Отсортирован по возрастанию</th>
      <th scope="col">Случайный порядок</th>
      <th scope="col">Отсортирован по убыванию</th>
    </tr>
  </thead>
  <tbody>
    <tr class="table-active">
      <th scope="row">Включение</th>
      <td>003 / 39:783</td>
      <td>003 / 34:078</td>
      <td>007 / 1:03:885</td>
    </tr>
    <tr class="table-primary">
      <th scope="row">Выбор</th>
      <td>003 / 39:719</td>
      <td>003 / 39:786</td>
      <td>003 / 40:903</td>
    </tr>
    <tr class="table-active">
      <th scope="row">Обмен</th>
      <td>004 / 40:856</td>
      <td>009 / 1:36:197</td>
      <td>011 / 1:47:388</td>
    </tr>
    <tr class="table-primary">
      <th scope="row">Шейкерная</th>
      <td>005 / 40:995</td>
      <td>009 / 1:25:540</td>
      <td>012 / 1:44:262</td>
    </tr>
    <tr class="table-active">
      <th scope="row">Быстрая</th>
      <td>001 / 012</td>
      <td>001 / 029</td>
      <td>001 / 012</td>
    </tr>
    <tr class="table-primary">
      <th scope="row">Пирамидальная</th>
      <td>002 / 063</td>
      <td>002 / 068</td>
      <td>002 / 058</td>
    </tr>
    <tr class="table-active">
      <th scope="row">J-сортировка</th>
      <td>002 / 065</td>
      <td>002 / 067</td>
      <td>002 / 063</td>
    </tr>
    <tr class="table-primary">
      <th scope="row">Слиянием</th>
      <td>002 / 1:157</td>
      <td>002 / 1:208</td>
      <td>002 / 1:178</td>
    </tr>
    <tr class="table-active">
      <th scope="row">Дерево</th>
      <td>002 / 063</td>
      <td>002 / 065</td>
      <td>002 / 060</td>
    </tr>
    <tr class="table-primary">
      <th scope="row">Порязрядная</th>
      <td>002 / 055</td>
      <td>002 / 053</td>
      <td>002 / 058</td>
    </tr>
  </tbody>
</table>


## Задачи

|  | Задача |
| :-: |-|
| 🐌 | |
| 🐣  | |
| 🐤  |  |
| 🐔 |  |
